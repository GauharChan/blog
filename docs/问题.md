## 继承

### [几种方式](https://juejin.im/post/5bcb2e295188255c55472db0)

#### 1. 原型链继承

> 将父类的实例赋值给子类的原型
>
> 数据在原型
>
> **缺点**：多个实例对引用类型的操作会被篡改

```js
Son.prototype = new Father()
```

#### 2. 借用构造函数继承

> 通过`call方法`把父类的构造函数重定义指向子类的构造函数
>
> 数据在构造函数

**缺点**：

- 只能继承父类的**实例**属性和方法，不能继承原型属性/方法
- 无法实现复用，每个子类都有父类实例函数的副本，影响性能

```js
function Son (){
	Father.call(this)
}
let son = new Son()
```

#### 3. 组合继承

> 利用原型链继承父类原型的属性方法；借用构造函数继承的方式继承实例上的属性和方法。结合起来就是组合继承
>
> **缺点**：调用了两次父类函数，其原型中会存在两份相同的属性/方法

```js
function Son (){
	Father.call(this)
}
Son.prototype = new Father()
let son = new Son()
```

#### 4. 原型式继承

> 利用一个空对象，把父类的属性方法赋值给空对象构造函数的原型，返回实例。
>
> `Object.create()`方法就是这样的意思

缺点：

- 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。
- 无法传递参数

```js
// 原型式
function Father(obj) {
    function f() {}
    f.prototype = obj
    return new f()
}
let person = {
    name: 'gauhar Person',
    arr: [1,2]
}

let s3 = Father(person)
console.dir(s3);



// 原型式   Object.create
let person = {
    name: 'gauhar Person',
    arr: [1,2]
}
let son = Object.create(person)
son.name = 'gauhar Son'
son.arr.push(3)
console.dir(son);
```

#### 5. 寄生式继承

> 使用原型式继承得到实例后，可以在实例的构造函数上绑定属性和方法
>
> 缺点：和原型式的缺点一样

```js
function Father(obj) {
    function f() {}
    f.prototype = obj
    return new f()
}
let person = {
    name: 'gauhar 原型',
    arr: [1,2]
}

function jisheng(parms) {
    let parasitism = Father(parms)
    parasitism.name = 'gauhar 构造'
    parasitism.say = function () {
        console.log('say 构造');
    }
    return parasitism
}

let ji = jisheng(person)
console.dir(ji);
ji.say()
```

#### 6. 寄生式组合继承

> 使用寄生式继承父类的原型，使用借用构造函数继承实例的属性方法和传参

```js
function Father(obj) {
    function f() {}
    f.prototype = obj
    return new f()
}
let person = {
    name: 'gauhar 原型',
    arr: [1, 2, '原型']
}

function jisheng(parms) {
    let parasitism = Father(parms)
    parasitism.name = 'gauhar 构造'
    parasitism.say = function () {
        console.log('say 构造');
    }
    return parasitism
}

function composition(son, father) {
    let obj = jisheng(father)  // 寄生继承
    son.prototype = obj  // 将父类的实例对象赋值给子类的原型
    son.prototype.constructor = son
}

function father(name) {
    this.name = name
    this.age = 50
    this.colors = [1, 2, 3]
}
father.prototype.walk = function () {
    console.log('这是father, 走路太慢了');
}

function son(name) {
    father.call(this, name)
}

composition(son, father.prototype)
// 新增子类原型属性
son.prototype.sayAge = function () {
    alert(this.age);
}

let s5 = new son('父亲')
console.dir(s5);
s5.walk()
s5.colors.push('s5')

let s6 = new son('s6')
s6.colors.push('s6')
console.log(s5.colors); // [1, 2, 3, "s5"]
console.log(s6.colors); // [1, 2, 3, "s6"]
```

#### 7. 混入方式继承多个对象

> 通过借用构造函数的方式，可以继承多个对象的属性和方法
>
> `Object.create`继承一个父类的原型对象
>
> `Object.assign`混合继承其他父类的原型对象

```js
function Father1() {
    this.name = 'Father1'
}
Father1.prototype.say = function () {
    console.log(this.name);
}
function Father2() {
    this.age = 'Father2'
}
Father2.prototype.sayAge = function () {
    console.log(this.age);
}

function Myclass() {
    Father1.call(this)
    Father2.call(this)
}
Myclass.prototype = Object.create(Father1.prototype)  // 把父类1的原型对象赋值给子类原型的__proto__对象
// Myclass.prototype = Object.create(Father2.prototype)  // 会把father1的属性方法覆盖
// 混合其他
Object.assign(Myclass.prototype, Father2.prototype) // 把父类2的原型拷贝赋值给子类的原型
Myclass.prototype.son = function () {

}
Myclass.prototype.constructor = Myclass
let my = new Myclass()
console.dir(my)
```

#### 8. ES6类继承extends

> 其内部实现和寄生式组合继承一样，是语法糖

```js
// es6
class Father{
    constructor(like, hate){
        this.like = like
        this.hate = hate
    }
    get fruits(){
        return this.like
    }
    bad(){
        console.log('最不喜欢吃'+this.hate);
    }
}
class Son extends Father{
    constructor(sonLike, sonHate){
        super(sonLike, sonHate)  // 调用父类的构造函数
        this.name = 'sonName'
    }
}
let son = new Son('🍎', '🍌')
console.log(son.fruits);
son.bad()
console.log(son.name);
```

## [从UR输入到页面展现到底发生什么？](https://segmentfault.com/a/1190000017184701)

1. DNS 解析:将域名解析成 IP 地址
2. TCP 连接：TCP 三次握手
3. 发送 HTTP 请求
4. 服务器处理请求并返回 HTTP 报文
5. 浏览器解析渲染页面
6. 断开连接：TCP 四次挥手

### 三次握手

> 三次握手用以同步客户端和服务端的序列号和确认号。为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误
>

是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个数据包。

**通俗版**

 1. 由浏览器发起，告诉服务器我要发送请求了
 2. 由服务器发起，告诉浏览器我准备接收了
 3. 由浏览器发起，告诉服务器我马上就发了

**原理版**

 - 第一次握手(SYN=1, seq=x):

   客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。

   发送完毕后，客户端进入 `SYN_SEND` 状态。

 - 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):

   服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 `SYN_RCVD` 状态。

 - 第三次握手(ACK=1，ACKnum=y+1)

   客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1

   发送完毕后，客户端进入 `ESTABLISHED` 状态，当服务器端接收到这个包时，也进入 `ESTABLISHED` 状态，TCP 握手结束。

### 四次挥手

**通俗版**

1. 由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭
2. 由服务器发起的， 告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧
3. 由服务器发起，告诉浏 览器，我响应报文发送完了，你准备关闭吧)
4. 由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧

**原理版**

- 第一次挥手(FIN=1，seq=x)

  假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。

  发送完毕后，客户端进入 `FIN_WAIT_1` 状态。

- 第二次挥手(ACK=1，ACKnum=x+1)

  服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。

  发送完毕后，服务器端进入 `CLOSE_WAIT` 状态，客户端接收到这个确认包之后，进入 `FIN_WAIT_2` 状态，等待服务器端关闭连接。

- 第三次挥手(FIN=1，seq=y)

  服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。

  发送完毕后，服务器端进入 `LAST_ACK` 状态，等待来自客户端的最后一个ACK。

- 第四次挥手(ACK=1，ACKnum=y+1)

  客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 `TIME_WAIT`状态，等待可能出现的要求重传的 ACK 包。

  服务器端接收到这个确认包之后，关闭连接，进入 `CLOSED` 状态。

  客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 `CLOSED` 状态


## ajax

### 工作过程

> 创建`XMLHttpRequest`对象，调用`open`方法连接服务器，发送请求，获取服务端响应数据

### 原生用法

```js
var xmlHttp = new XMLHttpRequest();
xmlHttp.open('GET','demo.php','true');
xmlHttp.send()
xmlHttp.onreadystatechange = function(){
    if(xmlHttp.readyState === 4 & xmlHttp.status === 200){
        console.log(xmlHttp.responseText)
    }
}
```

### [jq用法](https://www.runoob.com/jquery/ajax-ajax.html)

```js
$.ajax({
    type: "method", // get, post
    url: "url",
    data: {
        op: ''
    },
    success: function (response) {

    },
    error(err){
        
    }
});
```

### axios

```js
axios({
  method: 'post',
  url: '/user/name',
  data: {
    firstName: 'Gauhar',
    lastName: 'Chan'
  }
});

// get
axios.get('demo/url', {
    params: {
        id: 1,
        name: 'Gauhar',
    },
   timeout: 1000,
  ...//其他相关配置
})

// post
axios.post('/user', {
    firstName: 'Gauhar',
    lastName: 'Chan'
}).then(function (response) {
    console.log(response);
}).catch(function (error) {
    console.log(error);
});
```



## [跨域](https://juejin.im/post/5c23993de51d457b8c1f4ee1)

> **当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域**。不同域之间相互请求资源，就是**跨域**

有三个标签是允许跨域加载资源：

- `<img src=XXX>`
- `<link href=XXX>`
- `<script src=XXX>`

### 解决方案

#### 1. JSONP

> **JSONP请求一定需要对方的服务器做支持才可以**，简单兼容性好，但仅仅支持`get`请求，不安全

1. 创建一个回调函数， 当服务器返回时自动执行（`callback(data)`），通过函数的参数可以获取到服务发回来的数据
2. 拼接好要传的参数，因为是get请求(params1=value&params2=value2)。并且约束好函数的`key`是`callback`，其他参数则是提交请求的参数
3. 创建一个`script`标签，把`url`和参数拼接起来，赋值给`script`标签的`src`，插入到`body`中

```js
// index.html
function jsonp({ url, params, callback }) {
    return new Promise((resolve, reject) => {
        let script = document.createElement('script')
        window[callback] = function (data) { // 编写一个回调函数
            resolve(data) // 返回服务器的数据
            document.body.removeChild(script) // 删除script标签
        }
        // 拼接
        params = { ...params, callback } // name=gauhar&callback=sayHi
        let arrs = []
        for (let key in params) {
            arrs.push(`${key}=${params[key]}`)
        }
        script.src = `${url}?${arrs.join('&')}`
        document.body.appendChild(script)
    })
}
jsonp({
    url: 'http://localhost:6688/say',
    params: { name: 'gauhar' },
    callback: 'sayHi'
}).then(data => {
    console.log(data) // hello gauhar
})
```

**jq写法**

```js
$.ajax({
    url: "http://localhost:6688/say",
    dataType: "jsonp",  // 使用jsonp跨域
    data:{
        name: 'gauhar'
    },
    success: function (data) {
        console.log(data);
    }
});
```

`node.js`代码

```js
let express = require('express')
let app = express()
app.get('/say', function(req, res) {
  let { name, callback } = req.query
  console.log(name) // gauhar
  console.log(callback) // sayHi
  res.end(`${callback}('hello ${name}')`)
})
app.listen(6688)
```



#### 2.代理

> vue-cli创建项目，在根目录下新建`vue.config.js`文件

```js
module.exports = {
  devServer: {
    proxy: {
      "/api": {
        target: "https://gauhar.top", // 实际的请求地址
        changeOrigin: true,  // 开启跨域
        pathRewrite: {'^/api' : ''}, // 来重写地址，将前缀 '/api' 转为 '/'
      },
      "/j": {
        target: "https://movie.douban.com",
        changeOrigin: true
      }
    }
  }
};
```

#### 3.cors

> 后端设置响应头:`Access-Control-Allow-Origin `

##### 简单请求

只要同时满足以下两大条件，就属于简单请求

条件1：使用下列方法之一：

- GET
- HEAD
- POST

条件2：Content-Type 的值仅限于下列三者之一：

- text/plain
- multipart/form-data
- application/x-www-form-urlencoded

##### 复杂请求

其他条件的情况就是复杂请求，复杂请求首先会发起一个`option`请求，判断服务端是否允许跨域

```js
// serve.js
const express = require('express')
const app = express()
app.use(function(req, res, next) {
    // 设置哪个源可以访问我
    res.setHeader('Access-Control-Allow-Origin', '*')
    // 允许携带哪个头访问我
    res.setHeader('Access-Control-Allow-Headers', '*')
    // // 允许哪个方法访问我
    res.setHeader('Access-Control-Allow-Methods', '*')

    if (req.method === 'OPTIONS') {
        // OPTIONS请求不做任何处理
        console.log(111);
    }
    next()
})
app.put('/put', function(req, res) {
  console.log(222);
  res.end('gauhar')
})
app.listen(4000, () => {
  console.log('running');
})
```

```js
// index.html
$.ajax({
    type: 'PUT',
    url: "http://localhost:4000/put",
    success: function (data) {
        console.log(data);
    }
});
```

运行代码可以看到，打印111，222。这说明复杂请求的时候，先发了一个`option`请求，确定允许跨域后再发起`put`请求，返回数据

## promise

> Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大
>
> 是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。

## vue

### mvvm

> M - Model 代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑
>
> V - View，代表 UI 组件，它负责将数据模型转化为 UI 展现出来 
>
> VM - ViewModel，监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步 View 和 Model 的对象，连接 Model 和 View

### [双向绑定原理](https://juejin.im/entry/5923973da22b9d005893805a)

### [vue-router](https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96)

#### 传参和取参

> path和query一起使用

```js
传参: 
this.$router.push({
        path:'/xxx',
        query:{
          id:id
        }
      })
  
接收参数:
this.$route.query.id
```

> name和params一起使用

```js
传参: 
this.$router.push({
        name:'xxx',
        params:{
          id:id
        }
      })
  
接收参数:
this.$route.params.id
```

- 1.`$router`为实例，想要导航到不同，则使用router.push方法
- 2.`$route`为当前router跳转对象，里面可以获取name、path、query、params等

**另外，二者还有点区别，直白的来说query相当于get请求，页面跳转的时候，可以在地址栏看到请求参数，而params相当于post请求，参数不会再地址栏中显示**



## JQuery

### 文件上传

```js
$('button').click(function(){
    var files = $('#avatar').prop('files');  // 获取文件对象
	// 使用Fromdata对象上传文件
    var data = new FormData();
    data.append('avatar', files[0]); // avatar是键名

    $.ajax({
        url: '/api/upload',
        type: 'POST',
        data: data,
        cache: false,  // 兼容IE8
        contentType: false, 
        processData: false,
    });
});
```

 `contentType: false`：jq默认设置`content-Type``为application/x-www-form-urlencoded`,这个是表单提交格式。文件上传的格式应该为`multipart/form-data`，`FormData`已经是这个格式，因此不使用`jq`的转换

`processData: false`：jQuery会将`data`对象转换为字符串来发送HTTP请求，默认情况下会用 `application/x-www-form-urlencoded`编码来进行转换。 我们设置`contentType: false`后该转换会失败，因此设置`processData: false`来禁止该转换过程

















